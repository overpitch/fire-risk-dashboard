<!DOCTYPE html>
<html lang='en'>
<head>
    <meta charset='UTF-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'>
    <title>Fire Weather Advisory</title>
    
    <!-- Simple red square favicon that should work in Safari -->
    <!-- <link rel="icon" href="favicon.png" type="image/png"> -->
    <link rel="icon" href="/static/favicon.ico" type="image/x-icon">
    <link href='https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css' rel='stylesheet'>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <link href='/static/synoptic-logo.css' rel='stylesheet'>
    <style>
        /* Attribution styles moved to external CSS file */
        .data-source {
            margin-bottom: 0.5rem;
        }
        .info-icon {
            cursor: pointer;
            color: #0d6efd;
            font-weight: bold;
            padding: 0 5px;
            border-radius: 50%;
            font-size: 0.8rem;
        }
        .info-icon:hover {
            text-decoration: none;
            color: #0a58ca;
        }
        .unavailable {
            background-color: #ffff99;
            padding: 0 4px;
            border-radius: 3px;
            font-style: italic;
        }
        .cache-info {
            font-size: 0.85rem;
            color: #6c757d;
            margin-bottom: 0.5rem;
        }
        .cache-fresh {
            color: #198754;
        }
        .cache-stale {
            color: #fd7e14;
        }
        /* Custom toggle colors for Test Mode */
        .form-check-input.normal-mode {
            background-color: #198754;  /* Bootstrap green */
            border-color: #198754;
        }
        .form-check-input.test-mode {
            background-color: #dc3545;  /* Bootstrap red */
            border-color: #dc3545;
        }
        #refresh-btn {
            margin-left: 10px;
            padding: 3px 10px;
            font-size: 0.9rem;
        }
        #data-status-btn {
            margin-left: 10px;
            padding: 3px 10px;
            font-size: 0.9rem;
        }
        /* Style for cached data display (REMOVED - Handled by modal now) */
        /* .cached-data-banner {
            background-color: #fff3cd;
            border: 2px dashed #ffc107;
            border-left: 10px solid #ffc107;
            padding: 10px 15px;
            margin-bottom: 15px;
            font-weight: bold;
            color: #856404;
        } */
        /* .cached-data-content {
            background-color: #fff8e6;
            border: 1px solid #ffeeba;
            padding: 15px;
        } */
        /* Custom style for wind gust tooltip */
        .tooltip-wide {
            min-width: 250px;
            max-width: 280px;
            text-align: center;
            font-size: 1.1em;
        }
        .tooltip-wide .tooltip-inner {
            max-width: 280px;
            padding: 8px 5px;
        }

        .weather-value-label {
          display: inline-block; /* Allows setting width */
          min-width: 250px; /* Increased from 230px to accommodate the longest label */
          /* Optional: margin-right: 5px; */
        }

        .threshold-info {
          display: inline-block;
          margin-left: 10px;
          font-size: 0.85rem;
          color: #6c757d;
          border-left: 1px solid #ddd;
          padding-left: 10px;
          width: 100px;
          text-align: right;
        }
        
        .data-age {
          font-size: 0.8rem;
          color: #fd7e14;
          font-style: italic;
          display: block;
          margin-top: 2px;
          margin-left: 12px; /* Indent slightly */
        }
    </style>
    <script>
        // Configure client-side settings
        const settings = {
            refreshInterval: 300000, // 5 minutes
            maxRetries: 3,
            retryDelay: 2000, // 2 seconds
            waitForFreshTimeout: 15000 // 15 seconds
        };
        
        async function fetchWithTimeout(url, options, timeout) {
            const controller = new AbortController();
            const id = setTimeout(() => controller.abort(), timeout);
            
            try {
                const response = await fetch(url, {
                    ...options,
                    signal: controller.signal
                });
                clearTimeout(id);
                return response;
            } catch (error) {
                clearTimeout(id);
                throw error;
            }
        }
            
        async function fetchFireRisk(showSpinner = false, waitForFresh = false) {
            // Show loading state if requested (for manual refresh)
            if (showSpinner) {
                document.getElementById('refresh-btn').innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Refreshing...';
                document.getElementById('refresh-btn').disabled = true;
            }
            
            let retries = 0;
            let success = false;
            let data;
            
            while (!success && retries < settings.maxRetries) {
                try {
                    // Add wait_for_fresh parameter if specified
                    const apiUrl = waitForFresh ?
                        '/fire-risk?wait_for_fresh=true' :
                        '/fire-risk';
                    
                    // Use timeout to prevent indefinite waiting
                    const timeout = waitForFresh ?
                        settings.waitForFreshTimeout :
                        10000; // 10 seconds for normal requests
                    
                    const response = await fetchWithTimeout(apiUrl, {}, timeout);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error ${response.status}`);
                    }
                    
                    data = await response.json();
                    success = true;
                    
                } catch (error) {
                    retries++;
                    console.error(`Error fetching data (attempt ${retries}/${settings.maxRetries}):`, error);
                    
                    if (retries < settings.maxRetries) {
                        // Add exponential backoff for retries
                        const delay = settings.retryDelay * Math.pow(2, retries - 1);
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
            }
            
            if (!success) {
                // All retries failed
                if (showSpinner) {
                    document.getElementById('refresh-btn').innerHTML = 'Refresh Failed - Try Again';
                    document.getElementById('refresh-btn').disabled = false;
                }
                return false;
            }
            
            try {
                // Update the UI with the fetched data
                const riskDiv = document.getElementById('fire-risk');
                const weatherDetails = document.getElementById('weather-details');
                const timestampDiv = document.getElementById('timestamp');
                const cacheInfoDiv = document.getElementById('cache-info');
                const dataStatusBtn = document.getElementById('data-status-btn'); // New button
                const dataStatusModalBody = document.getElementById('dataStatusModalBody'); // Modal body

                // Update fire risk text (simplified)
                riskDiv.innerText = `Fire Risk: ${data.risk} - ${data.explanation}`;
                
                // Update cache information
                if (data.cache_info) {
                    // Parse the ISO string with timezone info
                    const lastUpdated = new Date(data.cache_info.last_updated);
                    const isFresh = data.cache_info.is_fresh;
                    const refreshInProgress = data.cache_info.refresh_in_progress;
                    // const usingCachedData = data.cache_info.using_cached_data; // No longer needed here

                    // Check if any data is older than 1 hour (stale)
                    const hasStaleData = () => {
                        if (!data.weather.cached_fields || !data.weather.cached_fields.timestamp) {
                            return false; // No cached data
                        }
                        
                        const now = new Date();
                        const ONE_HOUR_MS = 60 * 60 * 1000;
                        
                        // Check each timestamp field
                        for (const field in data.weather.cached_fields.timestamp) {
                            if (data.weather.cached_fields.timestamp[field]) {
                                const dataTime = new Date(data.weather.cached_fields.timestamp[field]);
                                const ageMs = now - dataTime;
                                
                                if (ageMs >= ONE_HOUR_MS) {
                                    return true; // Found stale data
                                }
                            }
                        }
                        
                        return false; // No stale data found
                    };
                    
                    // Update data status button based on staleness (over 1 hour old)
                    const dataIsStale = hasStaleData();
                    
                    if (!dataIsStale) {
                        dataStatusBtn.textContent = 'Fresh Data';
                        dataStatusBtn.classList.remove('btn-warning');
                        dataStatusBtn.classList.add('btn-success');
                    } else {
                        dataStatusBtn.textContent = 'Older Data'; // Changed from "Stale Data" to "Older Data"
                        dataStatusBtn.classList.remove('btn-success');
                        dataStatusBtn.classList.add('btn-warning');
                    }
                    dataStatusBtn.disabled = false; // Enable button once data loads

                    // Update Modal Content based on backend data
                    let modalHTML = '';
                    if (data.modal_content) {
                        if (data.modal_content.note) {
                            modalHTML += `<div class="alert alert-info p-2 small"><strong>NOTE:</strong> ${data.modal_content.note}</div>`;
                        }
                        if (data.modal_content.warning_title && data.modal_content.warning_issues && data.modal_content.warning_issues.length > 0) {
                            modalHTML += `<div class="alert alert-warning p-2 small">
                                <strong>${data.modal_content.warning_title}</strong><br>
                                <ul class="mb-0">
                                    ${data.modal_content.warning_issues.map(issue => `<li>${issue}</li>`).join('')}
                                </ul>
                            </div>`;
                        }
                    }
                    if (!modalHTML) {
                         modalHTML = '<p>Data is current and no quality issues detected.</p>'; // Default message
                    }
                    dataStatusModalBody.innerHTML = modalHTML;


                    // Update Cache Info Div (Timestamp only)
                    // Extract timezone abbreviation from timestamp
                    // This will properly display the timezone from the server
                    const timeZoneAbbr = (() => {
                        // The timestamp from the server now includes timezone info
                        // We can get the timezone offset directly from the parsed date
                        const offset = lastUpdated.getTimezoneOffset();
                        const offsetHours = Math.abs(Math.floor(offset / 60));
                        
                        // Check if we're in DST based on timezone offset
                        const jan = new Date(lastUpdated.getFullYear(), 0, 1).getTimezoneOffset();
                        const jul = new Date(lastUpdated.getFullYear(), 6, 1).getTimezoneOffset();
                        const isDST = offset < Math.max(jan, jul);
                        
                        // For Pacific Time
                        if (offset >= 420 && offset <= 480) { // -7 or -8 hours
                            return isDST ? 'PDT' : 'PST';
                        }
                        return `GMT${offset <= 0 ? '+' : '-'}${offsetHours}`;
                    })();
                    
                    if (refreshInProgress) {
                        statusText += ' (refresh in progress...)'; // Keep refresh status
                    } else {
                         statusText = ''; // Clear status text if not refreshing
                    }

                    cacheInfoDiv.innerHTML = `
                        <span class="cache-info">
                           Last updated: ${lastUpdated.toLocaleTimeString()} ${timeZoneAbbr} ${statusText}
                        </span>`;
                } else {
                     cacheInfoDiv.innerHTML = `<span class="cache-info">Last updated: Unavailable</span>`; // Fallback
                }

                // Set appropriate background color based on risk level
                const riskLevel = data.risk;
                let bgClass = 'bg-secondary';  // Default for unknown/error risk
                let customStyle = '';

                if (riskLevel === 'Red') {
                    bgClass = 'text-white'; // Text color for Red risk
                    customStyle = 'background-color: #FF0000;'; // Red hex color
                } else if (riskLevel === 'Orange') {
                    bgClass = 'text-dark'; // Text color for Orange risk
                    customStyle = 'background-color: #FFA500;'; // Orange hex color
                }
                // Always set background color based on risk level now
                riskDiv.className = `alert ${bgClass} p-3`;
                riskDiv.style = customStyle; // Apply custom hex color

                // Update weather details
                // Convert temperature from Celsius to Fahrenheit using the formula F = (C * 9/5) + 32
                // Round all measurements to the nearest whole number
                const tempCelsius = data.weather.air_temp;
                // Check if we have cached values for any missing fields
                const isCachedTemp = data.weather.cached_fields && data.weather.cached_fields.temperature;
                const isCachedSoilMoisture = data.weather.cached_fields && data.weather.cached_fields.soil_moisture;
                
                // Use cached values if available, otherwise show unavailable
                // Format age for cached data
                const formatAge = (timestamp) => {
                    if (!timestamp) return "";
                    
                    const now = new Date();
                    const dataTime = new Date(timestamp);
                    const ageMs = now - dataTime;
                    
                    // Convert to minutes
                    const ageMinutes = Math.round(ageMs / (1000 * 60));
                    
                    if (ageMinutes < 60) {
                        return `${ageMinutes} minute${ageMinutes !== 1 ? 's' : ''} old`;
                    } else if (ageMinutes < 24 * 60) {
                        const hours = Math.round(ageMinutes / 60);
                        return `${hours} hour${hours !== 1 ? 's' : ''} old`;
                    } else if (ageMinutes < 7 * 24 * 60) {
                        const days = Math.round(ageMinutes / (60 * 24));
                        return `${days} day${days !== 1 ? 's' : ''} old`;
                    } else {
                        const weeks = Math.round(ageMinutes / (60 * 24 * 7));
                        return `${weeks} week${weeks !== 1 ? 's' : ''} old`;
                    }
                };
                
                // Add age info as a second line for cached data
                const getTempDisplay = () => {
                    // Check if we're in test mode or using cached data
                    const usingCachedData = data.cache_info && data.cache_info.using_cached_data;
                    
                    // If we're in test mode and have a timestamp, show age indicator even if primary data exists
                    if (isCachedTemp && data.weather.cached_fields.timestamp && usingCachedData) {
                        const tempValue = Math.round((tempCelsius || data.weather.cached_fields.temperature) * 9/5) + 32 + '°F';
                        const ageText = formatAge(data.weather.cached_fields.timestamp.temperature);
                        return `${tempValue}<br><span class="data-age">(${ageText})</span>`;
                    } else if (tempCelsius) {
                        return Math.round((tempCelsius * 9/5) + 32) + '°F';
                    } else if (isCachedTemp && data.weather.cached_fields.timestamp) {
                        const tempValue = Math.round((data.weather.cached_fields.temperature) * 9/5) + 32 + '°F';
                        const ageText = formatAge(data.weather.cached_fields.timestamp.temperature);
                        return `${tempValue}<br><span class="data-age">(${ageText})</span>`;
                    } else {
                        return '<span class="unavailable">&lt;unavailable&gt;</span>';
                    }
                };
                
                const getSoilMoistureDisplay = () => {
                    // Check if we're in test mode or using cached data
                    const usingCachedData = data.cache_info && data.cache_info.using_cached_data;
                    
                    // If we're in test mode and have a timestamp, show age indicator even if primary data exists
                    if (isCachedSoilMoisture && data.weather.cached_fields.timestamp && usingCachedData) {
                        const moistureValue = Math.round(data.weather.soil_moisture_15cm || data.weather.cached_fields.soil_moisture) + '%';
                        const ageText = formatAge(data.weather.cached_fields.timestamp.soil_moisture);
                        return `${moistureValue}<br><span class="data-age">(${ageText})</span>`;
                    } else if (data.weather.soil_moisture_15cm) {
                        return Math.round(data.weather.soil_moisture_15cm) + '%';
                    } else if (isCachedSoilMoisture && data.weather.cached_fields.timestamp) {
                        const moistureValue = Math.round(data.weather.cached_fields.soil_moisture) + '%';
                        const ageText = formatAge(data.weather.cached_fields.timestamp.soil_moisture);
                        return `${moistureValue}<br><span class="data-age">(${ageText})</span>`;
                    } else {
                        return '<span class="unavailable">&lt;unavailable&gt;</span>';
                    }
                };
                
                const tempFahrenheit = getTempDisplay();
                const soilMoisture = getSoilMoistureDisplay();
                const weatherStation = data.weather.data_sources.weather_station;
                const soilStation = data.weather.data_sources.soil_moisture_station;
                
                // Check for data issues
                const dataStatus = data.weather.data_status;
                const hasIssues = dataStatus && dataStatus.issues && dataStatus.issues.length > 0;
                // Build the weather details HTML (Removed NOTE and Warning - now in modal)
                let detailsHTML = `<h5>Current Weather Conditions:</h5>`;
                
                // Handle potentially missing data with fallbacks - round all values to nearest whole number
                // Check if we have cached values for any missing fields
                const isCachedHumidity = data.weather.cached_fields && data.weather.cached_fields.humidity;
                const isCachedWindSpeed = data.weather.cached_fields && data.weather.cached_fields.wind_speed;
                const isCachedWindGust = data.weather.cached_fields && data.weather.cached_fields.wind_gust;
                
                // Create display functions for remaining weather metrics with age-based formatting
                const getHumidityDisplay = () => {
                    // Check if we're in test mode or using cached data
                    const usingCachedData = data.cache_info && data.cache_info.using_cached_data;
                    
                    // If we're in test mode and have a timestamp, show age indicator even if primary data exists
                    if (isCachedHumidity && data.weather.cached_fields.timestamp && usingCachedData) {
                        const humidValue = Math.round(data.weather.relative_humidity || data.weather.cached_fields.humidity) + '%';
                        const ageText = formatAge(data.weather.cached_fields.timestamp.humidity);
                        return `${humidValue}<br><span class="data-age">(${ageText})</span>`;
                    } else if (data.weather.relative_humidity) {
                        return Math.round(data.weather.relative_humidity) + '%';
                    } else if (isCachedHumidity && data.weather.cached_fields.timestamp) {
                        const humidValue = Math.round(data.weather.cached_fields.humidity) + '%';
                        const ageText = formatAge(data.weather.cached_fields.timestamp.humidity);
                        return `${humidValue}<br><span class="data-age">(${ageText})</span>`;
                    } else {
                        return '<span class="unavailable">&lt;unavailable&gt;</span>';
                    }
                };
                
                const getWindSpeedDisplay = () => {
                    // Check if we're in test mode or using cached data
                    const usingCachedData = data.cache_info && data.cache_info.using_cached_data;
                    
                    // If we're in test mode and have a timestamp, show age indicator even if primary data exists
                    if (isCachedWindSpeed && data.weather.cached_fields.timestamp && usingCachedData) {
                        const speedValue = Math.round(data.weather.wind_speed || data.weather.cached_fields.wind_speed) + ' mph';
                        const ageText = formatAge(data.weather.cached_fields.timestamp.wind_speed);
                        return `${speedValue}<br><span class="data-age">(${ageText})</span>`;
                    } else if (data.weather.wind_speed !== null && data.weather.wind_speed !== undefined) {
                        return Math.round(data.weather.wind_speed) + ' mph';
                    } else if (isCachedWindSpeed && data.weather.cached_fields.timestamp) {
                        const speedValue = Math.round(data.weather.cached_fields.wind_speed) + ' mph';
                        const ageText = formatAge(data.weather.cached_fields.timestamp.wind_speed);
                        return `${speedValue}<br><span class="data-age">(${ageText})</span>`;
                    } else {
                        return '<span class="unavailable">&lt;unavailable&gt;</span>';
                    }
                };
                
                const getWindGustDisplay = () => {
                    // Check if we're in test mode or using cached data
                    const usingCachedData = data.cache_info && data.cache_info.using_cached_data;
                    
                    // If we're in test mode and have a timestamp, show age indicator even if primary data exists
                    if (isCachedWindGust && data.weather.cached_fields.timestamp && usingCachedData) {
                        const gustValue = Math.round(data.weather.wind_gust || data.weather.cached_fields.wind_gust) + ' mph';
                        const ageText = formatAge(data.weather.cached_fields.timestamp.wind_gust);
                        return `${gustValue}<br><span class="data-age">(${ageText})</span>`;
                    } else if (data.weather.wind_gust !== null && data.weather.wind_gust !== undefined) {
                        return Math.round(data.weather.wind_gust) + ' mph';
                    } else if (isCachedWindGust && data.weather.cached_fields.timestamp) {
                        const gustValue = Math.round(data.weather.cached_fields.wind_gust) + ' mph';
                        const ageText = formatAge(data.weather.cached_fields.timestamp.wind_gust);
                        return `${gustValue}<br><span class="data-age">(${ageText})</span>`;
                    } else {
                        return '<span class="unavailable">&lt;unavailable&gt;</span>';
                    }
                };
                
                // Get display values for all metrics
                const humidity = getHumidityDisplay();
                const windSpeed = getWindSpeedDisplay();
                const windGust = getWindGustDisplay();
                const windGustStation = data.weather.data_sources.wind_gust_station;
                
                // Get threshold values from API response or use defaults if not available
                const THRESH_TEMP = data.thresholds ? data.thresholds.temp : 75; // Temperature threshold in Fahrenheit
                const THRESH_HUMID = data.thresholds ? data.thresholds.humid : 15; // Humidity threshold in percent (below this is risky)
                const THRESH_WIND = data.thresholds ? data.thresholds.wind : 15;  // Wind speed threshold in mph
                const THRESH_GUSTS = data.thresholds ? data.thresholds.gusts : 20; // Wind gust threshold in mph
                const THRESH_SOIL_MOIST = data.thresholds ? data.thresholds.soil_moist : 10; // Soil moisture threshold in percent (below this is risky)
                
                // Check if values exceed thresholds for color formatting - use rounded values
                const tempValue = tempCelsius ? Math.round((tempCelsius * 9/5) + 32) : null;
                const tempExceeds = tempValue !== null && tempValue > THRESH_TEMP;
                
                const humidValue = data.weather.relative_humidity ? Math.round(data.weather.relative_humidity) : null;
                const humidExceeds = humidValue !== null && humidValue < THRESH_HUMID;
                
                const windValue = data.weather.wind_speed ? Math.round(data.weather.wind_speed) : null;
                const windExceeds = windValue !== null && windValue > THRESH_WIND;
                
                const gustValue = data.weather.wind_gust ? Math.round(data.weather.wind_gust) : null;
                const gustExceeds = gustValue !== null && gustValue > THRESH_GUSTS;
                
                const soilValue = data.weather.soil_moisture_15cm ? Math.round(data.weather.soil_moisture_15cm) : null;
                const soilExceeds = soilValue !== null && soilValue < THRESH_SOIL_MOIST;

                // Removed weatherContainerClass - no special styling needed here now

                // Create a style for the threshold display (used temporarily during revert then replaced)
                const thresholdStyle = "display: inline-block; margin-left: 10px; font-size: 0.85rem; color: #6c757d; border-left: 1px solid #ddd; padding-left: 10px;";

                detailsHTML += `
                    <div>
                        <ul>
                            <li style="color: ${tempExceeds ? 'red' : 'black'}">
                                <span class="weather-value-label">
                                    <span style="color: ${tempExceeds ? 'red' : 'black'}">Temperature: ${tempFahrenheit}</span>
                                </span>
                                <span class="threshold-info">Thresholds: >${THRESH_TEMP}°F</span>
                                <span class="info-icon" data-bs-toggle="tooltip" data-bs-html="true" title="Sierra City<br>From: Synoptic Data">ⓘ</span>
                            </li>
                            <li style="color: ${humidExceeds ? 'red' : 'black'}">
                                <span class="weather-value-label">
                                    <span style="color: ${humidExceeds ? 'red' : 'black'}">Humidity: ${humidity}</span>
                                </span>
                                <span class="threshold-info"><${THRESH_HUMID}%</span>
                                <span class="info-icon" data-bs-toggle="tooltip" data-bs-html="true" title="Sierra City<br>From: Synoptic Data">ⓘ</span>
                            </li>
                            <li style="color: ${windExceeds ? 'red' : 'black'}">
                                <span class="weather-value-label">
                                    <span style="color: ${windExceeds ? 'red' : 'black'}">Wind Speed: ${windSpeed}</span>
                                </span>
                                <span class="threshold-info">>${THRESH_WIND} mph</span>
                                <span class="info-icon" data-bs-toggle="tooltip" data-bs-html="true" title="Sierra City<br>From: Synoptic Data">ⓘ</span>
                            </li>
                            <li style="color: ${gustExceeds ? 'red' : 'black'}">
                                <span class="weather-value-label">
                                    <span style="color: ${gustExceeds ? 'red' : 'black'}">Wind Gusts: ${windGust}</span>
                                </span>
                                <span class="threshold-info">>${THRESH_GUSTS} mph</span>
                                <span class="info-icon wind-gust-info" data-bs-toggle="tooltip" data-bs-html="true" 
                                      title="Loading wind gust data...">ⓘ</span>
                            </li>
                            <li style="color: ${soilExceeds ? 'red' : 'black'}">
                                <span class="weather-value-label">
                                    <span style="color: ${soilExceeds ? 'red' : 'black'}">Soil Moisture (15cm depth): ${soilMoisture}</span>
                                </span>
                                <span class="threshold-info"><${THRESH_SOIL_MOIST}%</span>
                                <span class="info-icon" data-bs-toggle="tooltip" data-bs-html="true" title="Downieville<br>From: Synoptic Data">ⓘ</span>
                            </li>
                        </ul>
                    </div>`;
                    
                weatherDetails.innerHTML = detailsHTML;
                    
                // Update timestamp and re-enable refresh button if it was used
                const now = new Date();
                
                // Get the timezone abbreviation using the same method as above
                const timeZoneAbbr = (() => {
                    const offset = now.getTimezoneOffset();
                    const offsetHours = Math.abs(Math.floor(offset / 60));
                    
                    // Check if we're in DST based on timezone offset
                    const jan = new Date(now.getFullYear(), 0, 1).getTimezoneOffset();
                    const jul = new Date(now.getFullYear(), 6, 1).getTimezoneOffset();
                    const isDST = offset < Math.max(jan, jul);
                    
                    // For Pacific Time
                    if (offset >= 420 && offset <= 480) { // -7 or -8 hours
                        return isDST ? 'PDT' : 'PST';
                    }
                    return `GMT${offset <= 0 ? '+' : '-'}${offsetHours}`;
                })();
                
                timestampDiv.innerText = `Last updated: ${now.toLocaleDateString()} at ${now.toLocaleTimeString()} ${timeZoneAbbr}`;
                
                if (showSpinner) {
                    document.getElementById('refresh-btn').innerHTML = 'Refresh Data';
                    document.getElementById('refresh-btn').disabled = false;
                }
                
                // Update the wind gust tooltip with station data
                if (data.weather.wind_gust_stations) {
                    const tooltipContent = buildWindGustTooltip(data.weather.wind_gust_stations);
                    const windGustTooltip = document.querySelector('.wind-gust-info');
                    if (windGustTooltip) {
                        // Update the tooltip content
                        const tooltip = bootstrap.Tooltip.getInstance(windGustTooltip);
                        if (tooltip) {
                            tooltip.dispose(); // Remove existing tooltip
                        }
                        windGustTooltip.setAttribute('title', tooltipContent);
                        // Reinitialize the tooltip with the wide template
                        new bootstrap.Tooltip(windGustTooltip, {
                            template: '<div class="tooltip tooltip-wide" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
                            html: true
                        });
                    }
                }
                
                return true; // Signal success
                
            } catch (error) {
                console.error("Error fetching fire risk data:", error);
                if (showSpinner) {
                    document.getElementById('refresh-btn').innerHTML = 'Refresh Failed - Try Again';
                    document.getElementById('refresh-btn').disabled = false;
                }
                return false;
            }
        }

        // Build tooltip content for wind gust stations
        function buildWindGustTooltip(stationsData) {
            if (!stationsData) {
                return "Wind gust data unavailable";
            }
            
            let tooltipContent = "<strong>Wind Gust Data</strong><br>";
            let hasData = false;
            
            // Loop through each station
            for (const stationId in stationsData) {
                const stationData = stationsData[stationId];
                
                if (stationData) {
                    hasData = true;
                    const value = stationData.value !== null ? Math.round(stationData.value) + " mph" : "unavailable";
                    const isCached = stationData.is_cached;
                    
                    // Format timestamp if available
                    let ageInfo = "";
                    if (isCached && stationData.timestamp) {
                        const now = new Date();
                        const timestamp = new Date(stationData.timestamp);
                        const ageMinutes = Math.floor((now - timestamp) / (1000 * 60));
                        
                        if (ageMinutes < 60) {
                            ageInfo = ` ${ageMinutes}m old`;
                        } else {
                            const ageHours = Math.floor(ageMinutes / 60);
                            ageInfo = ` ${ageHours}h old`;
                        }
                    }
                    
                    const statusIndicator = isCached ? `⚠️${ageInfo}` : "✓";
                    tooltipContent += `<div style="margin: 3px 0;">${stationId}: <strong>${value}</strong> ${statusIndicator}</div>`;
                }
            }
            
            if (!hasData) {
                return "No wind gust data available from any station";
            }
            
            tooltipContent += "<div style='margin-top: 3px; font-size: 0.9em;'>From: Wunderground</div>";
            return tooltipContent;
        }
        
        // Initialize tooltips
        function initializeTooltips() {
            const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
            tooltipTriggerList.map(function (tooltipTriggerEl) {
                // Apply the wide class to the wind gust tooltip only
                if (tooltipTriggerEl.closest('li') && tooltipTriggerEl.closest('li').textContent.includes('Wind Gusts')) {
                    return new bootstrap.Tooltip(tooltipTriggerEl, {
                        template: '<div class="tooltip tooltip-wide" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>'
                    });
                }
                // Use default tooltip for all other elements
                return new bootstrap.Tooltip(tooltipTriggerEl);
            });
        }
        
        // Handle manual refresh button click - uses waitForFresh=true to ensure we get fresh data
        function manualRefresh() {
            // Pass true for both showSpinner and waitForFresh
            fetchFireRisk(true, true).then(success => {
                if (success !== false) {
                    initializeTooltips();
                }
            });
        }

        // Test Mode Toggle Functionality
        async function toggleTestMode(enable) {
            // Update the toggle color immediately
            const testModeToggle = document.getElementById('testModeToggle');
            if (enable) {
                // Switch to red for test mode
                testModeToggle.classList.remove('normal-mode');
                testModeToggle.classList.add('test-mode');
            } else {
                // Switch to green for normal mode
                testModeToggle.classList.remove('test-mode');
                testModeToggle.classList.add('normal-mode');
            }

            try {
                const response = await fetch(`/toggle-test-mode?enable=${enable}`, {
                    method: 'GET'
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    // Log success message based on mode
                    if (enable) {
                        console.log('Test mode enabled. Using cached data.');
                    } else {
                        console.log('Test mode disabled. Returned to normal operation.');
                    }
                    
                    // Refresh the data display to show the changes
                    fetchFireRisk(true, true).then(success => {
                        if (success !== false) {
                            initializeTooltips();
                        }
                    });
                    
                    // Don't save test mode state to localStorage anymore
                    // We want test mode to always start disabled by default
                    
                    return true;
                } else {
                    console.error(`Error toggling test mode: ${data.message}`);
                    alert(`Error: ${data.message}`);
                    
                    // Reset the toggle to its previous state without triggering the change event
                    const testModeToggle = document.getElementById('testModeToggle');
                    testModeToggle.checked = !enable;
                    
                    return false;
                }
            } catch (error) {
                console.error('Error toggling test mode:', error);
                alert('Error toggling test mode. See console for details.');
                
                // Reset the toggle to its previous state without triggering the change event
                const testModeToggle = document.getElementById('testModeToggle');
                testModeToggle.checked = !enable;
                
                return false;
            }
        }
        
        // Auto-refresh functionality
        function setupRefresh() {
            // Set up the test mode toggle event listener
            const testModeToggle = document.getElementById('testModeToggle');
            testModeToggle.addEventListener('change', function() {
                toggleTestMode(this.checked);
            });
            
            // Always start in normal mode
            testModeToggle.checked = false;
            testModeToggle.classList.add('normal-mode');
            
            // Clear any previously saved test mode state from localStorage
            localStorage.removeItem('testModeEnabled');
            
            // Initial load without waiting for fresh data
            fetchFireRisk().then(success => {
                if (success !== false) {
                    initializeTooltips();
                }
            });
            
            // Setup auto-refresh
            setInterval(() => {
                // Don't wait for fresh data on auto-refresh, to prevent hanging the UI
                fetchFireRisk(false, false).then(success => {
                    if (success !== false) {
                        initializeTooltips();
                    }
                });
            }, settings.refreshInterval);
        }

        window.onload = setupRefresh;
    </script>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-primary" style="background-color: #003366 !important;">
        <div class="container">
            <a class="navbar-brand fw-bold" href="#">
                Fire Weather Advisory  —  Sierra City, CA
            </a>
            <div class="d-flex align-items-center">
                <div class="ms-auto d-flex align-items-center me-3">
                    <div class="form-check form-switch d-flex align-items-center">
                        <span class="text-light me-3" style="font-size: 0.9rem; min-width: 60px; text-align: right;">Normal</span>
                        <input class="form-check-input normal-mode" type="checkbox" id="testModeToggle" style="cursor: pointer; margin-left: 0;">
                        <label class="form-check-label text-light ms-2" for="testModeToggle" style="font-size: 0.9rem;">Test</label>
                    </div>
                </div>
                <button class="btn btn-outline-light" data-bs-toggle="modal" data-bs-target="#aboutUsModal">About Us</button>
            </div>
        </div>
    </nav>
    
    <div class="container mt-5">
    
    <div class="d-flex justify-content-between align-items-center mb-2 mt-3">
        <div id="cache-info" class="cache-info">Last updated: Loading...</div>
        <div> <!-- Wrapper div for buttons -->
            <button id="data-status-btn" class="btn btn-sm btn-secondary" data-bs-toggle="modal" data-bs-target="#dataStatusModal" disabled>Data Status</button>
            <button id="refresh-btn" class="btn btn-sm btn-outline-primary" onclick="manualRefresh()">Refresh Data</button>
        </div>
    </div>
    
    <div id='fire-risk' class='alert alert-info'>Loading fire risk data...</div>
    <div id='weather-details' class='mt-3'></div>
    
    <div class="alert mt-4 mb-4" style="background-color: #d1ecff;">
        <p>Fire weather needs to be local. A few Sierra City residents analyze local wind, humidity, temperature and soil moisture data and offer their advice in real time. This fire weather advisory is a best guess of what you should know about local fire weather conditions before there is a fire event.</p>
        
        <p>The two-stage advisory (Orange for Low or Moderate Risk, Red for Extreme Risk) is distributed via email and text each morning. Should fire weather conditions change during the course of the day, additional advisories will be issued.</p>
        
        <p class="mb-0">This fire weather advisory is not a substitute for official notifications by law enforcement or other government or private agencies.</p>
    </div>
    
    <div class="attribution-container mt-4">
        <div id="timestamp" class="timestamp">Last updated: Loading...</div>
        <div class="attribution">
            Weather observations aggregated by&nbsp;<a href="https://www.wunderground.com/" target="_blank">Weather Underground</a>&nbsp;and&nbsp;<a href="https://synopticdata.com/" target="_blank">Synoptic Data</a>&nbsp;
            <img src="/static/synoptic-logo.png" alt="Synoptic Data" class="synoptic-logo">
        </div>
    </div>
    
    <!-- About Us Modal -->
    <div class="modal fade" id="aboutUsModal" tabindex="-1" aria-labelledby="aboutUsModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="aboutUsModalLabel">About Us</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>This Fire Weather Advisory website was born from the Sierra City Community Radio1 (SCCR1) initiative. SCCR1 provides essential communication via handheld radios when power, phone, and internet services are disrupted, while also fostering stronger neighborhood connections.</p>
                    
                    <p>It was inspired by a January 2025 incident when high winds during low humidity reignited a burn pile. We realized many residents were unaware of these dangerous weather conditions. After community discussions, we developed this advisory system to keep our neighbors informed and safer.</p>
                    
                    <p>For more information about our services or to manage your notification preferences, please contact us at <a href="mailto:fredsnarf@getlost.com">fredsnarf@getlost.com</a>.</p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Data Status Modal -->
    <div class="modal fade" id="dataStatusModal" tabindex="-1" aria-labelledby="dataStatusModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="dataStatusModalLabel">Data Status Details</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body" id="dataStatusModalBody">
            <!-- Content will be populated by JavaScript -->
            Loading status details...
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
          </div>
        </div>
      </div>
    </div>

    </div> <!-- Close container -->
</body>
</html>
